#include <Tests/CatchRodos/TestMacros.hpp>

#include <Sts1CobcSw/ChannelCoding/ChannelCoding.hpp>
#include <Sts1CobcSw/ChannelCoding/ReedSolomon.hpp>
#include <Sts1CobcSw/ChannelCoding/Scrambler.hpp>
#include <Sts1CobcSw/Outcome/Outcome.hpp>
#include <Sts1CobcSw/Serial/Byte.hpp>

#include <algorithm>
#include <array>
#include <cstddef>
#include <cstdint>
#include <span>


namespace rs = sts1cobcsw::rs;

using sts1cobcsw::Byte;
using sts1cobcsw::operator""_b;


namespace
{
template<std::size_t size>
constexpr auto GenerateSequentialBytes(Byte startValue = 0_b) -> std::array<Byte, size>
{
    auto result = std::array<Byte, size>{};
    for(auto i = 0U; i < size; ++i)
    {
        result[i] = static_cast<Byte>(static_cast<std::uint8_t>(startValue) + i);
    }
    return result;
}
}


TEST_CASE("Reed-Solomon")
{
    auto block = std::array<Byte, rs::blockLength>{};
    auto message = std::array<Byte, rs::messageLength>{};
    auto paritySymbols = std::array<Byte, rs::nParitySymbols>{};
    static constexpr auto originalMessage = GenerateSequentialBytes<rs::messageLength>();

    // Encode() computes the correct parity symbols
    {
        std::ranges::copy(originalMessage, block.begin());
        rs::Encode(std::span(block).first<rs::messageLength>(),
                   std::span(block).last<rs::nParitySymbols>());
        static constexpr auto correctParitySymbols = std::array{
            0x4f_b, 0xfb_b, 0x92_b, 0xdd_b, 0x55_b, 0x7e_b, 0xc6_b, 0x7f_b, 0x27_b, 0xfb_b, 0x89_b,
            0x82_b, 0xcf_b, 0x58_b, 0xf8_b, 0xfd_b, 0x02_b, 0x8a_b, 0xd1_b, 0x17_b, 0xfc_b, 0xef_b,
            0x6b_b, 0x27_b, 0x93_b, 0xd0_b, 0x41_b, 0x88_b, 0x26_b, 0x57_b, 0x86_b, 0x51_b};
        std::ranges::copy(std::span(block).last<rs::nParitySymbols>(), paritySymbols.begin());
        CHECK(paritySymbols == correctParitySymbols);
    }

    // Up to nParitySymbols / 2 errors can be corrected
    {
        static constexpr auto nErrors = sts1cobcsw::nParitySymbols / 2U;

        std::ranges::copy(originalMessage, block.begin());
        rs::Encode(std::span(block).first<rs::messageLength>(),
                   std::span(block).last<rs::nParitySymbols>());
        for(auto i = 0U; i < nErrors; ++i)
        {
            block[i] ^= 0xFF_b;
        }
        auto decodeResult = rs::Decode(block);
        CHECK(decodeResult.has_value());
        CHECK(decodeResult.value() == static_cast<int>(nErrors));
        std::copy_n(block.begin(), message.size(), message.begin());
        CHECK(message == originalMessage);

        for(auto i = 0U; i < nErrors / 2; ++i)
        {
            block[5 * i + 2] ^= 0xFF_b;
        }
        decodeResult = rs::Decode(block);
        CHECK(decodeResult.has_value());
        CHECK(decodeResult.value() == static_cast<int>(nErrors / 2));
        std::copy_n(block.begin(), message.size(), message.begin());
        CHECK(message == originalMessage);

        for(auto i = 0U; i < nErrors + 1U; ++i)
        {
            block[i] ^= 0xFF_b;
        }
        decodeResult = rs::Decode(block);
        CHECK(decodeResult.has_error());
        CHECK(decodeResult.error() == sts1cobcsw::ErrorCode::errorCorrectionFailed);
        std::copy_n(block.begin(), message.size(), message.begin());
        CHECK(message != originalMessage);
    }
}


TEST_CASE("Scrambler")
{
    static constexpr auto originalData = GenerateSequentialBytes<rs::blockLength>();

    // Unscramble() is the inverse of Scramble()
    {
        auto data = originalData;
        sts1cobcsw::tc::Scramble(data);
        sts1cobcsw::tc::Unscramble(data);
        CHECK(data == originalData);

        sts1cobcsw::tm::Scramble(data);
        sts1cobcsw::tm::Unscramble(data);
        CHECK(data == originalData);
    }

    // Regression tests
    {
        auto data = originalData;
        sts1cobcsw::tc::Unscramble(data);
        static constexpr auto correctlyUnscrambledData = std::array{
            0xff_b, 0x38_b, 0x9c_b, 0x59_b, 0x6c_b, 0xec_b, 0x00_b, 0xf2_b, 0x64_b, 0x80_b, 0x25_b,
            0xaa_b, 0x3d_b, 0x53_b, 0x06_b, 0xcf_b, 0x42_b, 0xb9_b, 0xa9_b, 0xbd_b, 0x5a_b, 0xd7_b,
            0xd1_b, 0xfa_b, 0x7e_b, 0xc5_b, 0x22_b, 0xcf_b, 0xe4_b, 0x9b_b, 0x4e_b, 0x22_b, 0xde_b,
            0x52_b, 0x1e_b, 0x97_b, 0xf5_b, 0xf7_b, 0x2b_b, 0xcd_b, 0xf1_b, 0x3b_b, 0x75_b, 0x69_b,
            0x4e_b, 0x91_b, 0x3f_b, 0xaf_b, 0x95_b, 0x60_b, 0x45_b, 0x6f_b, 0xa9_b, 0xb0_b, 0xb9_b,
            0xed_b, 0xf5_b, 0x81_b, 0x4b_b, 0x92_b, 0xcd_b, 0x31_b, 0x9e_b, 0x44_b, 0xbc_b, 0xa7_b,
            0x3b_b, 0x2a_b, 0xe7_b, 0xe1_b, 0x5d_b, 0x92_b, 0xfa_b, 0x6d_b, 0xf4_b, 0xcf_b, 0x89_b,
            0x35_b, 0x6d_b, 0x4e_b, 0x1a_b, 0xf3_b, 0xbc_b, 0xea_b, 0x6f_b, 0x5e_b, 0x49_b, 0xe2_b,
            0xc3_b, 0x29_b, 0xb9_b, 0x08_b, 0xbe_b, 0x44_b, 0x1e_b, 0xa8_b, 0x99_b, 0xad_b, 0x90_b,
            0xb0_b, 0x23_b, 0x2d_b, 0x51_b, 0xcc_b, 0x0c_b, 0x20_b, 0x17_b, 0x62_b, 0xe6_b, 0x9d_b,
            0x28_b, 0x6d_b, 0xe5_b, 0x34_b, 0xaf_b, 0x01_b, 0x02_b, 0x63_b, 0x49_b, 0x1c_b, 0x4e_b,
            0x98_b, 0xbc_b, 0xdc_b, 0xb8_b, 0x4f_b, 0xff_b, 0x90_b, 0x73_b, 0x18_b, 0x67_b, 0x25_b,
            0x0a_b, 0x15_b, 0xe9_b, 0xd1_b, 0x40_b, 0x1b_b, 0x70_b, 0x98_b, 0x99_b, 0x6d_b, 0x02_b,
            0x8a_b, 0xba_b, 0x1a_b, 0x28_b, 0x77_b, 0x78_b, 0xb9_b, 0xe8_b, 0x41_b, 0xf5_b, 0x5a_b,
            0x17_b, 0xd4_b, 0x14_b, 0xf8_b, 0x9d_b, 0x40_b, 0x47_b, 0x92_b, 0x69_b, 0xee_b, 0xb9_b,
            0x85_b, 0x78_b, 0x0a_b, 0x39_b, 0x8c_b, 0x5e_b, 0x8d_b, 0x87_b, 0x6c_b, 0xb6_b, 0xa5_b,
            0xe5_b, 0xa6_b, 0xc7_b, 0x7a_b, 0x6c_b, 0xed_b, 0x4b_b, 0x1b_b, 0x63_b, 0x3e_b, 0xa0_b,
            0x24_b, 0xac_b, 0x77_b, 0xb9_b, 0x00_b, 0x0e_b, 0xa6_b, 0x54_b, 0x59_b, 0xfe_b, 0x84_b,
            0x7b_b, 0x9c_b, 0xea_b, 0x82_b, 0x22_b, 0x87_b, 0x9b_b, 0x4f_b, 0xfe_b, 0xdb_b, 0x7a_b,
            0xff_b, 0x39_b, 0x40_b, 0x64_b, 0x64_b, 0x2d_b, 0x8e_b, 0x6f_b, 0xd7_b, 0xef_b, 0xe5_b,
            0xfd_b, 0x49_b, 0xd1_b, 0xa0_b, 0x7c_b, 0x2e_b, 0xcf_b, 0xd7_b, 0x90_b, 0x66_b, 0x9c_b,
            0x51_b, 0xac_b, 0x7e_b, 0x3a_b, 0x73_b, 0x43_b, 0xe9_b, 0x8e_b, 0xc6_b, 0xa4_b, 0xac_b,
            0x25_b, 0xd4_b, 0x95_b, 0x96_b, 0x00_b, 0x44_b, 0x96_b, 0xe5_b, 0x90_b, 0x87_b, 0xbf_b,
            0xd5_b, 0xe0_b};
        CHECK(data == correctlyUnscrambledData);

        data = originalData;
        sts1cobcsw::tm::Scramble(data);
        static constexpr auto correctlyScrambledData = std::array{
            0xff_b, 0x49_b, 0x0c_b, 0xc3_b, 0x9e_b, 0x08_b, 0x76_b, 0xbb_b, 0x86_b, 0x25_b, 0x99_b,
            0xa6_b, 0xab_b, 0xba_b, 0x48_b, 0xc1_b, 0x4a_b, 0x86_b, 0x6f_b, 0xdf_b, 0x26_b, 0xb7_b,
            0xa9_b, 0x29_b, 0x12_b, 0x09_b, 0xeb_b, 0x93_b, 0x88_b, 0xd0_b, 0xf4_b, 0xae_b, 0xde_b,
            0xb1_b, 0x3f_b, 0xa2_b, 0x10_b, 0x3f_b, 0xc7_b, 0x5e_b, 0x34_b, 0x70_b, 0x0d_b, 0x70_b,
            0x63_b, 0x43_b, 0xa3_b, 0xb3_b, 0x85_b, 0x1f_b, 0xc9_b, 0xab_b, 0x51_b, 0x70_b, 0x48_b,
            0x4b_b, 0x2c_b, 0x18_b, 0xd9_b, 0x2a_b, 0x15_b, 0xa6_b, 0xeb_b, 0x5c_b, 0xbd_b, 0x61_b,
            0x79_b, 0x41_b, 0x2c_b, 0x70_b, 0x84_b, 0xb5_b, 0x70_b, 0xfb_b, 0x04_b, 0xfd_b, 0xd2_b,
            0x90_b, 0x55_b, 0x76_b, 0x3a_b, 0x0c_b, 0xa5_b, 0x63_b, 0x9e_b, 0xdf_b, 0xaa_b, 0xaf_b,
            0x70_b, 0x1a_b, 0x9c_b, 0x79_b, 0x0f_b, 0x6a_b, 0xf4_b, 0x98_b, 0x9a_b, 0x21_b, 0x14_b,
            0x67_b, 0xb4_b, 0x0e_b, 0xe3_b, 0x83_b, 0x19_b, 0x0d_b, 0xf7_b, 0x06_b, 0x51_b, 0xd7_b,
            0x58_b, 0x1d_b, 0xa4_b, 0xca_b, 0x9c_b, 0x12_b, 0xe1_b, 0x60_b, 0x8f_b, 0x87_b, 0x28_b,
            0xfe_b, 0xf6_b, 0x3f_b, 0xda_b, 0x12_b, 0x2b_b, 0xf0_b, 0x74_b, 0x01_b, 0x6e_b, 0x8a_b,
            0x24_b, 0x52_b, 0x8d_b, 0x4f_b, 0x6a_b, 0x40_b, 0xb0_b, 0x51_b, 0xf7_b, 0xf9_b, 0xe2_b,
            0x6a_b, 0x39_b, 0xe6_b, 0x4e_b, 0x50_b, 0xbe_b, 0xbe_b, 0x65_b, 0x77_b, 0x39_b, 0x96_b,
            0x82_b, 0x12_b, 0xd0_b, 0x43_b, 0x35_b, 0x80_b, 0x49_b, 0xa0_b, 0x7a_b, 0xb0_b, 0xe5_b,
            0x0b_b, 0xb1_b, 0x36_b, 0x6d_b, 0x3b_b, 0xdf_b, 0x1f_b, 0x5a_b, 0x45_b, 0x77_b, 0x64_b,
            0xe2_b, 0x5e_b, 0x0b_b, 0x35_b, 0xe0_b, 0xe2_b, 0x51_b, 0x76_b, 0xfa_b, 0xa7_b, 0x8b_b,
            0xa9_b, 0x25_b, 0x00_b, 0xe8_b, 0x80_b, 0x12_b, 0xc2_b, 0x72_b, 0xe5_b, 0x47_b, 0x99_b,
            0xe9_b, 0xe4_b, 0x43_b, 0xed_b, 0x21_b, 0xa2_b, 0x21_b, 0x1c_b, 0x7d_b, 0x59_b, 0x75_b,
            0x0e_b, 0xa1_b, 0xdf_b, 0x7c_b, 0x7a_b, 0x19_b, 0x55_b, 0x5c_b, 0xe5_b, 0xb8_b, 0xfe_b,
            0xef_b, 0xa7_b, 0x72_b, 0xa0_b, 0x44_b, 0xe6_b, 0x82_b, 0xae_b, 0xe2_b, 0x5d_b, 0xb8_b,
            0xa0_b, 0xfe_b, 0xa0_b, 0x3c_b, 0x38_b, 0x37_b, 0x4e_b, 0x89_b, 0xc2_b, 0xbb_b, 0x4f_b,
            0x14_b, 0xea_b, 0xa5_b, 0xaa_b, 0x69_b, 0xf2_b, 0xf0_b, 0x81_b, 0x3e_b, 0xb1_b, 0x9a_b,
            0x08_b, 0xa6_b};
        CHECK(data == correctlyScrambledData);
    }
}


TEST_CASE("Channel coding")
{
    auto block = std::array<Byte, rs::blockLength>{};
    auto message = std::array<Byte, rs::messageLength>{};
    static constexpr auto originalMessage = GenerateSequentialBytes<rs::messageLength>();

    // Decoding is the inverse of encoding
    {
        std::ranges::copy(originalMessage, block.begin());
        sts1cobcsw::tc::Encode(block);
        auto decodeResult = sts1cobcsw::tc::Decode(block);
        CHECK(decodeResult.has_value());
        CHECK(decodeResult.value() == 0);
        std::copy_n(block.begin(), message.size(), message.begin());
        CHECK(message == originalMessage);

        std::ranges::copy(originalMessage, block.begin());
        sts1cobcsw::tm::Encode(block);
        decodeResult = sts1cobcsw::tm::Decode(block);
        CHECK(decodeResult.has_value());
        CHECK(decodeResult.value() == 0);
        std::copy_n(block.begin(), message.size(), message.begin());
        CHECK(message == originalMessage);
    }

    // Up to nParitySymbols / 2 errors can be corrected
    {
        static constexpr auto nErrors = sts1cobcsw::nParitySymbols / 2U;

        std::ranges::copy(originalMessage, block.begin());
        sts1cobcsw::tm::Encode(block);
        for(auto i = 0U; i < nErrors; ++i)
        {
            block[i] ^= 0xFF_b;
        }
        auto decodeResult = sts1cobcsw::tm::Decode(block);
        CHECK(decodeResult.has_value());
        CHECK(decodeResult.value() == static_cast<int>(nErrors));
        std::copy_n(block.begin(), message.size(), message.begin());
        CHECK(message == originalMessage);

        std::ranges::copy(originalMessage, block.begin());
        sts1cobcsw::tc::Encode(block);
        for(auto i = 0U; i < nErrors; ++i)
        {
            block[i] ^= 0xFF_b;
        }
        decodeResult = sts1cobcsw::tc::Decode(block);
        CHECK(decodeResult.has_value());
        CHECK(decodeResult.value() == static_cast<int>(nErrors));
        std::copy_n(block.begin(), message.size(), message.begin());
        CHECK(message == originalMessage);
    }

    // Regression test
    {
        std::ranges::copy(originalMessage, block.begin());
        sts1cobcsw::tm::Encode(block);
        auto correctlyEncodedBlock = std::array{
            0xff_b, 0x49_b, 0x0c_b, 0xc3_b, 0x9e_b, 0x08_b, 0x76_b, 0xbb_b, 0x86_b, 0x25_b, 0x99_b,
            0xa6_b, 0xab_b, 0xba_b, 0x48_b, 0xc1_b, 0x4a_b, 0x86_b, 0x6f_b, 0xdf_b, 0x26_b, 0xb7_b,
            0xa9_b, 0x29_b, 0x12_b, 0x09_b, 0xeb_b, 0x93_b, 0x88_b, 0xd0_b, 0xf4_b, 0xae_b, 0xde_b,
            0xb1_b, 0x3f_b, 0xa2_b, 0x10_b, 0x3f_b, 0xc7_b, 0x5e_b, 0x34_b, 0x70_b, 0x0d_b, 0x70_b,
            0x63_b, 0x43_b, 0xa3_b, 0xb3_b, 0x85_b, 0x1f_b, 0xc9_b, 0xab_b, 0x51_b, 0x70_b, 0x48_b,
            0x4b_b, 0x2c_b, 0x18_b, 0xd9_b, 0x2a_b, 0x15_b, 0xa6_b, 0xeb_b, 0x5c_b, 0xbd_b, 0x61_b,
            0x79_b, 0x41_b, 0x2c_b, 0x70_b, 0x84_b, 0xb5_b, 0x70_b, 0xfb_b, 0x04_b, 0xfd_b, 0xd2_b,
            0x90_b, 0x55_b, 0x76_b, 0x3a_b, 0x0c_b, 0xa5_b, 0x63_b, 0x9e_b, 0xdf_b, 0xaa_b, 0xaf_b,
            0x70_b, 0x1a_b, 0x9c_b, 0x79_b, 0x0f_b, 0x6a_b, 0xf4_b, 0x98_b, 0x9a_b, 0x21_b, 0x14_b,
            0x67_b, 0xb4_b, 0x0e_b, 0xe3_b, 0x83_b, 0x19_b, 0x0d_b, 0xf7_b, 0x06_b, 0x51_b, 0xd7_b,
            0x58_b, 0x1d_b, 0xa4_b, 0xca_b, 0x9c_b, 0x12_b, 0xe1_b, 0x60_b, 0x8f_b, 0x87_b, 0x28_b,
            0xfe_b, 0xf6_b, 0x3f_b, 0xda_b, 0x12_b, 0x2b_b, 0xf0_b, 0x74_b, 0x01_b, 0x6e_b, 0x8a_b,
            0x24_b, 0x52_b, 0x8d_b, 0x4f_b, 0x6a_b, 0x40_b, 0xb0_b, 0x51_b, 0xf7_b, 0xf9_b, 0xe2_b,
            0x6a_b, 0x39_b, 0xe6_b, 0x4e_b, 0x50_b, 0xbe_b, 0xbe_b, 0x65_b, 0x77_b, 0x39_b, 0x96_b,
            0x82_b, 0x12_b, 0xd0_b, 0x43_b, 0x35_b, 0x80_b, 0x49_b, 0xa0_b, 0x7a_b, 0xb0_b, 0xe5_b,
            0x0b_b, 0xb1_b, 0x36_b, 0x6d_b, 0x3b_b, 0xdf_b, 0x1f_b, 0x5a_b, 0x45_b, 0x77_b, 0x64_b,
            0xe2_b, 0x5e_b, 0x0b_b, 0x35_b, 0xe0_b, 0xe2_b, 0x51_b, 0x76_b, 0xfa_b, 0xa7_b, 0x8b_b,
            0xa9_b, 0x25_b, 0x00_b, 0xe8_b, 0x80_b, 0x12_b, 0xc2_b, 0x72_b, 0xe5_b, 0x47_b, 0x99_b,
            0xe9_b, 0xe4_b, 0x43_b, 0xed_b, 0x21_b, 0xa2_b, 0x21_b, 0x1c_b, 0x7d_b, 0x59_b, 0x75_b,
            0x0e_b, 0xa1_b, 0xdf_b, 0x7c_b, 0x7a_b, 0x19_b, 0x55_b, 0x5c_b, 0xe5_b, 0xb8_b, 0xfe_b,
            0xef_b, 0xa7_b, 0x72_b, 0x30_b, 0x5f_b, 0x95_b, 0xbd_b, 0x18_b, 0x78_b, 0x7e_b, 0x21_b,
            0x60_b, 0xed_b, 0xc0_b, 0x54_b, 0x1c_b, 0x83_b, 0x5b_b, 0x9a_b, 0x2f_b, 0xc1_b, 0x6f_b,
            0xf1_b, 0xe5_b, 0xbe_b, 0x34_b, 0xb8_b, 0x96_b, 0xd8_b, 0x39_b, 0x4c_b, 0x6c_b, 0x31_b,
            0x73_b, 0x09_b};
        CHECK(block == correctlyEncodedBlock);

        std::ranges::copy(originalMessage, block.begin());
        sts1cobcsw::tc::Encode(block);
        correctlyEncodedBlock = std::array{
            0xff_b, 0x38_b, 0x9c_b, 0x59_b, 0x6c_b, 0xec_b, 0x00_b, 0xf2_b, 0x64_b, 0x80_b, 0x25_b,
            0xaa_b, 0x3d_b, 0x53_b, 0x06_b, 0xcf_b, 0x42_b, 0xb9_b, 0xa9_b, 0xbd_b, 0x5a_b, 0xd7_b,
            0xd1_b, 0xfa_b, 0x7e_b, 0xc5_b, 0x22_b, 0xcf_b, 0xe4_b, 0x9b_b, 0x4e_b, 0x22_b, 0xde_b,
            0x52_b, 0x1e_b, 0x97_b, 0xf5_b, 0xf7_b, 0x2b_b, 0xcd_b, 0xf1_b, 0x3b_b, 0x75_b, 0x69_b,
            0x4e_b, 0x91_b, 0x3f_b, 0xaf_b, 0x95_b, 0x60_b, 0x45_b, 0x6f_b, 0xa9_b, 0xb0_b, 0xb9_b,
            0xed_b, 0xf5_b, 0x81_b, 0x4b_b, 0x92_b, 0xcd_b, 0x31_b, 0x9e_b, 0x44_b, 0xbc_b, 0xa7_b,
            0x3b_b, 0x2a_b, 0xe7_b, 0xe1_b, 0x5d_b, 0x92_b, 0xfa_b, 0x6d_b, 0xf4_b, 0xcf_b, 0x89_b,
            0x35_b, 0x6d_b, 0x4e_b, 0x1a_b, 0xf3_b, 0xbc_b, 0xea_b, 0x6f_b, 0x5e_b, 0x49_b, 0xe2_b,
            0xc3_b, 0x29_b, 0xb9_b, 0x08_b, 0xbe_b, 0x44_b, 0x1e_b, 0xa8_b, 0x99_b, 0xad_b, 0x90_b,
            0xb0_b, 0x23_b, 0x2d_b, 0x51_b, 0xcc_b, 0x0c_b, 0x20_b, 0x17_b, 0x62_b, 0xe6_b, 0x9d_b,
            0x28_b, 0x6d_b, 0xe5_b, 0x34_b, 0xaf_b, 0x01_b, 0x02_b, 0x63_b, 0x49_b, 0x1c_b, 0x4e_b,
            0x98_b, 0xbc_b, 0xdc_b, 0xb8_b, 0x4f_b, 0xff_b, 0x90_b, 0x73_b, 0x18_b, 0x67_b, 0x25_b,
            0x0a_b, 0x15_b, 0xe9_b, 0xd1_b, 0x40_b, 0x1b_b, 0x70_b, 0x98_b, 0x99_b, 0x6d_b, 0x02_b,
            0x8a_b, 0xba_b, 0x1a_b, 0x28_b, 0x77_b, 0x78_b, 0xb9_b, 0xe8_b, 0x41_b, 0xf5_b, 0x5a_b,
            0x17_b, 0xd4_b, 0x14_b, 0xf8_b, 0x9d_b, 0x40_b, 0x47_b, 0x92_b, 0x69_b, 0xee_b, 0xb9_b,
            0x85_b, 0x78_b, 0x0a_b, 0x39_b, 0x8c_b, 0x5e_b, 0x8d_b, 0x87_b, 0x6c_b, 0xb6_b, 0xa5_b,
            0xe5_b, 0xa6_b, 0xc7_b, 0x7a_b, 0x6c_b, 0xed_b, 0x4b_b, 0x1b_b, 0x63_b, 0x3e_b, 0xa0_b,
            0x24_b, 0xac_b, 0x77_b, 0xb9_b, 0x00_b, 0x0e_b, 0xa6_b, 0x54_b, 0x59_b, 0xfe_b, 0x84_b,
            0x7b_b, 0x9c_b, 0xea_b, 0x82_b, 0x22_b, 0x87_b, 0x9b_b, 0x4f_b, 0xfe_b, 0xdb_b, 0x7a_b,
            0xff_b, 0x39_b, 0x40_b, 0x64_b, 0x64_b, 0x2d_b, 0x8e_b, 0x6f_b, 0xd7_b, 0xef_b, 0xe5_b,
            0xfd_b, 0x49_b, 0xd1_b, 0x30_b, 0x67_b, 0x5d_b, 0xf0_b, 0x61_b, 0x0a_b, 0x45_b, 0x05_b,
            0x91_b, 0xbf_b, 0x1e_b, 0x52_b, 0x57_b, 0xf7_b, 0xfc_b, 0x9d_b, 0x2b_b, 0xde_b, 0x8c_b,
            0xc0_b, 0xdb_b, 0x8e_b, 0x08_b, 0xd1_b, 0x20_b, 0xbe_b, 0x5d_b, 0xe2_b, 0x5a_b, 0x14_b,
            0xae_b, 0x4f_b};
        CHECK(block == correctlyEncodedBlock);
    }
}
